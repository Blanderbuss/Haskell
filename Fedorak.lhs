Розглянемо наступну задачу:
Із аеропорту Хіроу потрібно доїхати до Лондона як можна швидше. При чому від аеропорта до міста йдуть дві основні дороги, які перетинаються великою кількістю доріг поменше.
Завдання:
Створити програму, що приймає на вхід представлення системи доріг і надрукує найкоротший шлях. Ось, як може виглядати вхідна інформація:

50
10
30
5
90
20
40
2
25
10
8
0

Щоби розібрати вхідні дані в голові, спробуйте уявити їх у вигляді дерева і розбийте систему доріг на секції. Кожна секція складається з дороги А, дороги Б і перетинаючої дороги. Зауважимо, що остання перетинаюча дорога має довжину 0, адже нам не важливо звідки саме ми в'їдемо в місто.
Будемо вирішувати задачу в три кроки:
1. На хвилинку забудьте про мову Haskell та подумайте, як би ви вирішували задачу в голові.
2. Подумайте про представлення даних у мові Haskell
3. З'ясуйте, як маніпулювати цими даними в мові Haskell, щоби отримати результат.

Обчислення найкоротшого шляху

Отже, як ми будемо шукати найкоротший шлях, не використовуючи програму? Якщо намалювати картинку з секціями і подивитись на неї, то можно прикинути, побачити найкоротший шлях. Але якщо на вході буде не 4 секції, а 10 000? Тоді ми не можемо знати, чи складене нами рішення буде оптимальним.
Пропонується такий варіант:
Щоби обчислити найкращий шлях від Хіроу, для початку треба знайти найкоротший шлях до перехрестя на дорохі А. Для кожної секції є два варіанта: одразу рухатись по А, або рухатись по Б і потім повернути на А. Запамятовуєм коротший шлях. Робимо аналогічні дії для дороги B. Так ми отримуємо вхідні дані для наступної секції. Залишилось лише проаналізувати всі секції і повернути коротший іх двох шляхів.
Тепер якщо є достатньо паперу, олівців і вільного часу можна розвязати цю задачу для будь-якої кількості секцій.

Представлення шляху на мові Haskell

Перейдемо до наступного кроку, як представити дорожню систему? Один із способів - вважати точки вузлами графа, що ведуть до інших вузлів. Врахувавши, що всі точки, крім кінцевих ведуть до двох доріг і мають довжину можна скласти таки тип даних:

> data Node = Node Road Road | EndNode Road
> data Road = Road Int Road

Можна було би використовувати тип Maybe, щоби не вводити новий конструктор для кінцевих вузлів

> data Node = Node Road (Maybe Road) 
> data Road = Road Int Road

Можна вирішити задачу таким способом представлення, але можна і придумати спосіб простіше. Якщо згадати задачу, як ми її розбирали в голові, то нам завжди були потрібні довжини трьох відрізків дороги: відрізок на дорозі А, відрізок на B і відрізок C, який їх з'єднує. Разом ці відрізки формують одну секцію. І тоді всю нашу дорожню систему можна представити у вигляді чотирьох секцій:
(50, 10, 30), (5, 90, 20), (40, 2, 25) и (10, 8, 0)
Завжди краще робити типи даних настільки простими, наскільки це можливо!

> data Section = Section { getA :: Int, getB :: Int, getC :: Int } deriving (Show)
> type RoadSystem = [Section]

Так набагато краще! Записується доволі просто, і у мене є передчуття, що для вирішення задачі такий опис підійде чудово. Секція представлена звичайним алгебраїчним типом даних, який має три числа для представлення трьох відрізків. 
Тепер дорожня система може бути представлена так: 

> heathrowToLondon :: RoadSystem
> heathrowToLondon = [ Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]

Все, що залишилось - розробити рішення на мові Haskell.

Реалізація пошуку оптимального шляху

Якою може бути деклараця типу для функції, обчислюючої найкоротший шлях для дорожньої системи? Вона має приймати дорожню систему і повертати шлях. Будемо представляти шлях у вигляді списку. Визначимо тип Label, що може приймати три фіксованих значення і синонім типу Path.

> data Label = A | B | C deriving (Show)
> type Path = [(Label,Int)]

І функцію, що шукає шлях:

> optimalPath :: RoadSystem -> Path

Якщо її викликати із системою heathrowToLondon, то вона має повернути такий шлях:
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]

Ми збираємось пройти по списку секцій зліва направо і зберігати оптимальні шляхи по ходу обходу списку. Для цього дуже зручно використати ліву згортку.
Прои вирішенні задачі вручну був крок, який потрібно було повторяти раз за разом - обчислення оптимального шляху до наступного перехрестя для доріг A i B. Якщо подивитись на це крок, як на функцію, то вона буде виглядати ось так:

> roadStep :: (Path, Path) –> Section –> (Path, Path)
> roadStep (pathA, pathB) (Section a b c) =
>  let timeA = sum $ map snd pathA
>      timeB = sum $ map snd pathB
>      forwardTimeToA = timeA + a
>      crossTimeToA = timeB + b + c
>      forwardTimeToB = timeB + b
>      crossTimeToB = timeA + a + c
>      newPathToA = if forwardTimeToA <= crossTimeToA
>      then (A,a):pathA
>      else (C,c):(B,b):pathB
>      newPathToB = if forwardTimeToB <= crossTimeToB
>      then (B,b):pathB
>      else (C,c):(A,a):pathA
>  in (newPathToA, newPathToB)

Як це працює? Для початку рахуєм шлях по А по уже складеному маршруту: sum $ map snd pathA. Те ж саме для B.
forwardTimeToA, crossTimeToA - прямий і "поворотний" до А. Коли ми їх знаєм - можна взяти коротшший і додати його до уже існуючого списку - newPathToA. Аналогічно для B.
Можна зауважити, що для такої функції ми отримаємо список секцій у зворотньому порядку, адже кожну наступну секцію дописуєм до початку списку((A,a):pathA). Але це набагато ефективніше, ніж кожного разу будувати список заново (pathA ++ [(A,a)]).
Ще одне зауваження - ми на кожному кроці обраховуєм довжину вхідного шляху. Цього можна уникнути, зберігаючи довжину шляху, разом із ним.
Тепер, маючи крок для foldl можна написати optimalPath:

> optimalPath :: RoadSystem –> Path
> optimalPath roadSystem =
>  let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem
>  in if sum (map snd bestAPath) <= sum (map snd bestBPath)
>  then reverse bestAPath
>  else reverse bestBPath

Ми виконуєм ліву згортку по roadSystem, вказуючи в якості початкового значення пару пустих шляхів. Результат згортки - пара шляхів, так що потрібно використати шаблон, щоби до них дістатись. Далі дивимся який шлях коротше і повертаєм його, попередньо обернувши.

Отримання опису дорожньої систему із зовнішнього джерела

Для початку напишем функцію, що приймає список і розбиває його на групи певного розміру, щоби зручно було передати результат у секції доріг.

> groupsOf :: Int –> [a] –> [[a]]
> groupsOf 0 _ = undefined
> groupsOf _ [] = []
> groupsOf n xs = take n xs : groupsOf n (drop n xs)

Тепер напишемо основну функцію, яка бере вхідні дані, створює RoadSystem і друкує шлях:

> main = do
>  contents <– getContents
>  let threes = groupsOf 3 (map read $ lines contents)
>      roadSystem = map (\([a,b,c]) –> (Section a b c)) threes
>      path = optimalPath roadSystem
>      pathString = concat $ map (show . fst) path
>      pathTime = sum $ map snd path
>  putStrLn $ "Кращий шлях: " ++ pathString
>  putStrLn $ "Час: " ++ show pathTime

На початку отримуєм дані із стандартного входу. Потім викликаєм lines з отриманими даними, щоби отримати список і mad read, щоби перетворити стрічки в числа. Розбиваємо список на групи і перетворюєм результат в RoadSystem, використувуючи анонімну функцію. Далі викликаєм optimalPath і друкуєм результат.
Все чудово працює!